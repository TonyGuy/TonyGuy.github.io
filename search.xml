<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>KMP算法</title>
      <link href="/2019/03/31/KMPAlgorithm/"/>
      <url>/2019/03/31/KMPAlgorithm/</url>
      
        <content type="html"><![CDATA[<p>KMP的精髓在于构造pa的前缀和后缀相同数组(next数组)，跳过相同的字符串对比。如<br>果匹配串没有相同的后缀和和前缀，那这个算法也就和BF算法差不多。</p><p>next数组的含义，后缀记录匹配串的前缀最后一个字符的后一个字符的下标，方便寻找<br>下一个匹配位置。</p><p>没有图说什么都没用，这里有个阿三讲解教学视频:<br><a href="https://www.bilibili.com/video/av3246487" target="_blank" rel="noopener">汪都能听懂的KMP字符串匹配算法(双语字幕)</a></p><h1 id="参考源代码："><a href="#参考源代码：" class="headerlink" title="参考源代码："></a>参考源代码：</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">KMP</span><span class="params">(<span class="built_in">string</span> str,<span class="built_in">string</span> pa)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len=pa.length();</span><br><span class="line">    <span class="keyword">int</span> next[len]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//构造前缀和后缀数组（next）</span></span><br><span class="line">    <span class="keyword">while</span>(j&lt;len)&#123;</span><br><span class="line">        <span class="keyword">if</span>(pa[i]==pa[j])&#123;</span><br><span class="line">            next[j]=++i;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//字符不相等，并且i不为零，i等于next前一个数值</span></span><br><span class="line">            <span class="keyword">if</span>(i)&#123;</span><br><span class="line">                i=next[--i];</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//开始匹配</span></span><br><span class="line">    i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">    len=str.length();</span><br><span class="line">    <span class="keyword">while</span>(i&lt;len)&#123;</span><br><span class="line">        <span class="keyword">if</span>(str[i+j]==pa[j])&#123;</span><br><span class="line">            <span class="comment">//当j等于模式串长度-1时候，就是说明匹配成功</span></span><br><span class="line">            <span class="keyword">if</span>(j==pa.length()<span class="number">-1</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//当j不为0时才取next数组的j前一个的数</span></span><br><span class="line">            <span class="keyword">if</span>(j)</span><br><span class="line">                j=next[j<span class="number">-1</span>];</span><br><span class="line">            i+=j+<span class="number">1</span>;</span><br><span class="line">            <span class="comment">//当i大于主串的长度减去匹配串的长度，就不用匹配</span></span><br><span class="line">            <span class="keyword">if</span>(i&gt;len-pa.length())</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有错误可以联系我或者github上留言（虽然知道没有人联系和留言，哈哈哈哈）</p><p>推荐看下同样的匹配算法：<a href="https://blog.csdn.net/q547550831/article/details/51860017" target="_blank" rel="noopener">Sunday算法</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>问题：模板类声明与实现</title>
      <link href="/2019/03/30/ProblemOfTemplateClass/"/>
      <url>/2019/03/30/ProblemOfTemplateClass/</url>
      
        <content type="html"><![CDATA[<p>在做单链表结构时发现模板类的声明与实现不能像一般类一样把它分成.h和.cpp文件，<br>不然会链接失败。</p><p>可是我不想写在一起，就是想分离，怎么办？<br>最后找到以下方法：</p><h1 id="方法一：在主文件中引入-cpp文件"><a href="#方法一：在主文件中引入-cpp文件" class="headerlink" title="方法一：在主文件中引入.cpp文件"></a>方法一：在主文件中引入.cpp文件</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这是A.h</span></span><br><span class="line">tamplate&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">T <span class="title">show</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line"><span class="comment">//一堆A类的声明...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这是A.cpp</span></span><br><span class="line">include<span class="string">"A.h"</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">T</span> <span class="title">A</span>&lt;T&gt;:</span>:show()&#123;</span><br><span class="line"><span class="comment">//balabala一堆</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//一堆A类的实现...</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这是主文件main.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"A.cpp"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>正常的类是在主文件中引入A.h，模板类需要引入A.cpp</p><p>究其原因，模板类的实现在找不到调用时，默认是不编译的，编译器会根据模板类的调<br>用类型分别编译成几个.O二进制文件，例如模板用到int和char，编译器会生成一个int<br>的.o文件和一个char的.o文件。所以只在主文件中引入.h文件(编译器就找不到实现)，<br>编译器就不会编译它的实现（.cpp文件）,那么在链接的时候就会出错（找不到实现函<br>数）</p><h1 id="方法二：在-h文件的底部引入-cpp"><a href="#方法二：在-h文件的底部引入-cpp" class="headerlink" title="方法二：在.h文件的底部引入.cpp"></a>方法二：在.h文件的底部引入.cpp</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这是A.h</span></span><br><span class="line">tamplate&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">T <span class="title">show</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line"><span class="comment">//一堆A类的声明...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"A.cpp"</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这是A.cpp</span></span><br><span class="line">include<span class="string">"A.h"</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">T</span> <span class="title">A</span>&lt;T&gt;:</span>:show()&#123;</span><br><span class="line"><span class="comment">//balabala一堆</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//一堆A类的实现...</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这是主文件main.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"A.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>其实这两种方法都是换汤不换药。</p><p>方法二的原理，主要与预编译include语句和.h文件不编译有关。看下下面的例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//state.h文件</span></span><br><span class="line"><span class="keyword">int</span> abc</span><br></pre></td></tr></table></figure></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//主文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"state.h"</span></span></span><br><span class="line">=<span class="number">50</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;abc;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种奇葩写法居然可以编译通过，并正常运行。。</p><p>在我的理解里，include是把.h文件以文本插入了主文件，所以说方法二是相当于把声明与实现写在同一个文件了</p><h1 id="总结一下："><a href="#总结一下：" class="headerlink" title="总结一下："></a>总结一下：</h1><ol><li>编译器默认编译所有.cpp文件，不编译.h文件（当然你也可以指定编译），但不编<br>译包含了模板的而又不找不到调用.cpp文件。</li><li>.h文件的声明只是让你编译通过，告诉编译器我有实现函数，模板实现函数却没有<br>编译（没有引入就找不到调用，没有调用就没有编译），导致链接失败。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> tips </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>问题：用typedef定义模板别名</title>
      <link href="/2019/03/29/differ-temp/"/>
      <url>/2019/03/29/differ-temp/</url>
      
        <content type="html"><![CDATA[<p>在上机课做LinkList的时候，用到模板结构体，就想着用typedef来定义一个结构体的指针:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">DT</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">typedef</span> <span class="title">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">DT data;</span><br><span class="line">Node&lt;DT&gt;* next;</span><br><span class="line">&#125;*PNode&lt;DT&gt;;</span><br></pre></td></tr></table></figure></p><p>竟然编译不通过。。。</p><p>最后改了下:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">DT</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">DT data;</span><br><span class="line">Node&lt;DT&gt;* next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">DT</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">typedef</span> <span class="title">Node</span>&lt;DT&gt; *<span class="title">PNode</span>;</span></span><br><span class="line"></span><br><span class="line">PNode&lt;<span class="keyword">int</span>&gt; pnode;</span><br></pre></td></tr></table></figure></p><p>O了？!</p><p>但回到宿舍,用GCC编译失败，，，最后找到解决办法使用using代替typedef:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">DT</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">DT data;</span><br><span class="line">Node&lt;DT&gt;* next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">DT</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">using</span> <span class="title">PNode</span> =<span class="title">Node</span>&lt;DT&gt;*;</span></span><br><span class="line"></span><br><span class="line">PNode&lt;<span class="keyword">int</span>&gt; pnode;</span><br></pre></td></tr></table></figure></p><p>其实导致上述错误是因为C++标准不同,上机课用的编译器是上古VC6.0，用的是古老的C++98标准，GCC编译器用的是C++11标准,C++11淘汰了typedef的用法。</p><p>至于为什么typedef的用法被淘汰了，可以参考以下链接:</p><p><a href="https://zhuanlan.zhihu.com/p/21264013" target="_blank" rel="noopener">Effective Modern C++ Note</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> tips </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>实验室任务</title>
      <link href="/2018/12/09/LibAssigement/"/>
      <url>/2018/12/09/LibAssigement/</url>
      
        <content type="html"><![CDATA[<p>任务要求: 抓取学校教务系统的个人信息和课表，做成网站访问。<br>工具: <strong>python</strong>（request，beautifulsoap，django），<strong>css</strong>，<strong>js</strong>，<strong>jquery</strong>，<strong>html</strong>，<strong>bootstrap</strong>(做UI）<br>具体过程: 用python的request库获取学生信息，再beautifulsoap解析，提取出学生信息，做成一个<strong>StudentInfo</strong>类。接下来用django搭建动态网站，用StudentInfo类代替数据库，在网页中用ajax获取数据，js加载布局。</p><p>效果如下：<br><img src="mainpage.png" alt="首页"><br><img src="infopage.jpg" alt="学生信息"></p><hr><p>唉，说一下做的过程中遇到的坑。</p><ul><li><h2 id="登录不上"><a href="#登录不上" class="headerlink" title="登录不上"></a>登录不上</h2><p>刚开始我把数据直接提交到登录url，登录不上，以为教务系统有识别爬虫的功能，于是把浏览器的请求头都添加上，但还是不行。看浏览器抓包，登录首页时，教务系统给了一个cookie，后来登录就要提交这个cookie。所以只要登录的时候，用request的session的请求一下首页，拿一下cookie就搞定了。</p></li><li><h2 id="解析信息"><a href="#解析信息" class="headerlink" title="解析信息"></a>解析信息</h2><p>python做信息字典的时候，忘了键值相同，会覆盖其值。。这个问题纳闷了几天。</p></li><li><h2 id="偷官网首页"><a href="#偷官网首页" class="headerlink" title="偷官网首页"></a>偷官网首页</h2><p>唉，偷首页还是不要偷上js，弄出一个ui，搞css和图片就好了。</p></li><li><h2 id="用mysql还是缓存？"><a href="#用mysql还是缓存？" class="headerlink" title="用mysql还是缓存？"></a>用mysql还是缓存？</h2><p>刚开始用mysql保存学生信息，最后决定用缓存保存学生信息。用mysql做代理网站太麻烦了，网站更新速度快，而且信息多，加上这些信息并不用保存太久。而一个StudentInfo类就保存全部，岂不美滋滋。</p></li></ul><hr><p>大学的第一个项目，用时大概一个月，由python学起，学到django的使用，后来发现即学即用效率是最高的，beatifulsoap，request，css，html，js，jquery都没有经过系统的学习，即学即用。<br>写这篇博客纪念一下，写完了，可以回去补高数了。</p><p>项目:<a href="https://github.com/TonyGuy/CrawlProject/" target="_blank" rel="noopener">盗版教务系统</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> HomeWork </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>第一次C++程序作业</title>
      <link href="/2018/11/14/FirstHW/"/>
      <url>/2018/11/14/FirstHW/</url>
      
        <content type="html"><![CDATA[<h3 id="身份证验证"><a href="#身份证验证" class="headerlink" title="身份证验证"></a>身份证验证</h3><p><a href="https://github.com/TonyGuy/HomeWork/blob/master/src/idCheck.cpp" target="_blank" rel="noopener">idCheck.cpp</a></p><h3 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h3><p><a href="https://github.com/TonyGuy/HomeWork/blob/master/src/hexConv.cpp" target="_blank" rel="noopener">hexConv.cpp</a></p><h3 id="字符统计"><a href="#字符统计" class="headerlink" title="字符统计"></a>字符统计</h3><p><a href="https://github.com/TonyGuy/HomeWork/blob/master/src/countText.cpp" target="_blank" rel="noopener">hexConv.cpp</a></p><h3 id="藏数游戏"><a href="#藏数游戏" class="headerlink" title="藏数游戏"></a>藏数游戏</h3><p><a href="https://github.com/TonyGuy/HomeWork/blob/master/src/hideNum.cpp" target="_blank" rel="noopener">hideNum.cpp</a></p><p>后面的两个程序有点水，不太严谨。如有改进的地方，可以在我的<a href="https://github.com/TonyGuy/HomeWork" target="_blank" rel="noopener">GitHub</a>上留言</p>]]></content>
      
      
      
        <tags>
            
            <tag> HomeWork </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>安装Hexo和部署到Github</title>
      <link href="/2018/10/11/HexoInstall/"/>
      <url>/2018/10/11/HexoInstall/</url>
      
        <content type="html"><![CDATA[<p>安装前先上一张流程图<br><img src="flow.png" alt="流程图" title="流程图"></p><h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><p>我用的系统是<strong>Debian</strong>，Windows、Macos的玩家可以上Hexo官网的<a href="https://hexo.io/docs/" target="_blank" rel="noopener">文档</a>查看教程,还有Centos，Redhat等系列的玩家虽然同属于Linux，但安装过程可能会有些不同，请自行<a href="https://www.baidu.com" target="_blank" rel="noopener">百度</a></p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>Hexo是一个用node.js框架编写的博客应用服务器，所以需提前安装好node.js。<br>Github是一个源码托管平台，用Hexo生成的静态网页文件部署到Gihub上，供外网的人访问（这样的发布方法不能被搜索引擎找到）。</p><hr><h2 id="开始安装"><a href="#开始安装" class="headerlink" title="开始安装"></a>开始安装</h2><h3 id="安装node-js"><a href="#安装node-js" class="headerlink" title="安装node.js"></a>安装node.js</h3><p>用curl或者wget获得安装器<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.11/install.sh | bash</span><br></pre></td></tr></table></figure></p><p>或<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wget -qO- https://raw.githubusercontent.com/creationix/nvm/v0.33.11/install.sh | bash</span><br></pre></td></tr></table></figure></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nvm install stable</span><br></pre></td></tr></table></figure><p>若无意外，到这里已经安装完成</p><h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure><h3 id="初始化一个博客"><a href="#初始化一个博客" class="headerlink" title="初始化一个博客"></a>初始化一个博客</h3><p>最好新建一个博客目录，摆放合理才是一个程序猿应有的规范<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init &lt;folder&gt;</span><br><span class="line">$ <span class="built_in">cd</span> &lt;folder&gt;</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure></p><p>初始化完成后，该目录会出现以下目录和文件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds</span><br><span class="line">├── <span class="built_in">source</span></span><br><span class="line">|   ├── _drafts</span><br><span class="line">|   └── _posts</span><br><span class="line">└── themes</span><br></pre></td></tr></table></figure></p><h3 id="运行服务器"><a href="#运行服务器" class="headerlink" title="运行服务器"></a>运行服务器</h3><p>在博客文件夹中运行<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure></p><p>访问localhost:4000，能正常访问，说明运行Hexo成功<br>接下来准备GitHub</p><h3 id="配置GitHub"><a href="#配置GitHub" class="headerlink" title="配置GitHub"></a>配置GitHub</h3><p>这里默认看客注册了Github帐号，没注册的<a href="https://www.github.com" target="_blank" rel="noopener">点这里</a><br>在Github上面创建一个新的repository，Repository name为 <strong>用户名</strong>.github.io。这是一个约定的Repository名，访问这个名字可以访问到当前Repository的静态网页（学生党福利），最后在该Repository的右上方有个绿色按钮Clone or download，复制里面的 <strong>SSH</strong> 链接!<br><img src="Git_Clone.png" alt="如图"></p><p>配置Github有两种方法：<strong>ssh帐号密码</strong> 和 <strong>ssh密钥</strong></p><h4 id="通过ssh帐号密码配置Github"><a href="#通过ssh帐号密码配置Github" class="headerlink" title="通过ssh帐号密码配置Github"></a>通过ssh帐号密码配置Github</h4><p>进入到博客文件中，修改_config.yml，一般在最后一行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">   type: git</span><br><span class="line">   repo: 用户名:密码@github.com:用户名/用户名.github.io.git</span><br><span class="line">   branch: master</span><br></pre></td></tr></table></figure></p><p>repo的链接为刚刚复制的链接，按照上面修改</p><h4 id="通过ssh密钥配置Github"><a href="#通过ssh密钥配置Github" class="headerlink" title="通过ssh密钥配置Github"></a>通过ssh密钥配置Github</h4><p>生成密钥<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C <span class="string">"youremail@example.com"</span></span><br></pre></td></tr></table></figure></p><p>-C 后面指定的是你注册GitHub的邮箱<br>回车之后，有三个输入，第一个输入是ssh密钥放置的路径（默认是目录下的.ssh）不输入即默认，第二个输入是密钥的密码，第三个确认密码。</p><p>进入家目录/.ssh/下，把公钥复制<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~/.ssh</span><br><span class="line">$ cat id_rsa.pub</span><br><span class="line">$ 一堆英文字符输出，复制这一堆东西</span><br></pre></td></tr></table></figure></p><p>上Github主页找到账户的Setting,把它复制到如下图，添加即可<br><img src="SSHkey.png" alt="如图"></p><p>添加完成后可以测试是否配置git完毕<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh git@github.com</span><br></pre></td></tr></table></figure></p><p>返回信息为Hi的话，则配置成功</p><h3 id="部署到Github上"><a href="#部署到Github上" class="headerlink" title="部署到Github上"></a>部署到Github上</h3><p>进入到hexo目录下，添加github的nodejs插件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></p><p>最后生成静态文件和部署到github上<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo g -d</span><br></pre></td></tr></table></figure></p><p>完成后，访问一下: <strong>用户名</strong>.github.io，正常访问就ok啦<br>若有其他疑问，请访问<a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Hexo</a>官网</p><hr><p>买了一个域名，以后可以通过<a href="http://www.tonyguy.online" target="_blank" rel="noopener">www.tonyguy.online</a>访问该博客</p>]]></content>
      
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
